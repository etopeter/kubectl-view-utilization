#!/usr/bin/env bash
#
# Copyright 2019 Peter Strzyzewski
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Prints cluster resource utilization


PLUGIN_VERSION="v0.1.4"
VIEW_UTILIZATION_NAMESPACE=""
VIEW_UTILIZATION_NODE_LABEL=""
VIEW_UTILIZATION_OUTPUT="text"
VIEW_UTILIZATION_SUBCOMMAND=""

print_plugin_version() {
    echo "${PLUGIN_VERSION}"
    exit
}

get_pod_data() {

    local template
    local namespace

    read -r -d '' template <<'EOF'
    {{/* get_pod_data */}}
    {{ range .items }}

        {{ $namespace:=.metadata.namespace }}
        {{ $node:=.spec.nodeName }}

        {{ range .spec.containers }}

            {{ $namespace }}
            {{ "\t" }}

            {{ $node }}
            {{"\t"}}

            {{ if .resources.requests.cpu }}
                {{ .resources.requests.cpu }}
            {{ else }}
                0
            {{end}}
            {{ "\t" }}

            {{ if .resources.requests.memory }}
                {{ .resources.requests.memory }}
            {{ else }}
                0Ki
            {{end}}
            {{ "\t" }}

            {{ if .resources.limits.cpu }}
                {{ .resources.limits.cpu }}
            {{ else }}
                0
            {{end}}
            {{ "\t" }}

            {{ if .resources.limits.memory }}
                {{ .resources.limits.memory }}
            {{ else }}
                0Ki
            {{end}}

            {{ "\n" }}

        {{end}}
    {{end}}
EOF

    # Debug
    # echo "${template//[$' \t\r\n']}" >&2

    if [ "${VIEW_UTILIZATION_NAMESPACE}" != "" ]; then
        namespace="--namespace=${VIEW_UTILIZATION_NAMESPACE}"
    else
        namespace="--all-namespaces"
    fi

    kubectl get pod $namespace --field-selector=status.phase=Running -o=go-template --template="${template//[$' \t\r\n']}"
}

get_node_data() {
    local node_label

    if [ "${VIEW_UTILIZATION_NODE_LABEL}" != "" ]; then
        node_label="-l ${VIEW_UTILIZATION_NODE_LABEL}"
    fi

    # shellcheck disable=SC2086
    kubectl get nodes $node_label -o=jsonpath="{range .items[*]}{.metadata.name}{'\t'}{.status.allocatable.cpu}{'\t'}{.status.allocatable.memory}{'\n'}{end}"
}


cluster_utilization() {

    # shellcheck disable=SC2016
    awkcmd='BEGIN {FS="\t"};
    NR==FNR { node[$1]; }

    NR==FNR && $2 ~ /[0-9]$/ { alloc_cpu+=$2*1000; };
    NR==FNR && $2 ~ /m?$/    { alloc_cpu+=$2; };
    NR==FNR && $3 ~ /Ki?$/   { alloc_mem+=$3*1024; next };

    # CPU requests
    $2 in node && $3 ~ /[0-9]$/ { req_cpu+=$3*1000; };
    $2 in node && $3 ~ /m?$/    { req_cpu+=$3; };

    # memory requests
    $2 in node && $4 ~ /m$/         { req_mem+=$4/1000; next };  # there is a bug where bytes are given a unit of "m" but multiplied by 1000
    $2 in node && $4 ~ /[kK](i)?$/  { req_mem+=$4*1024; };
    $2 in node && $4 ~ /M(i)?$/     { req_mem+=$4*1048576; };
    $2 in node && $4 ~ /[gG](i)?$/  { req_mem+=$4*1073741824; };
    $2 in node && $4 ~ /[tT](i)?$/  { req_mem+=$4*1099511627776; };

    # CPU limits
    $2 in node && $5 ~ /[0-9]$/ { lim_cpu+=$5*1000; };
    $2 in node && $5 ~ /m?$/    { lim_cpu+=$5; };

    # memory limits
    $2 in node && $6 ~ /m$/         { lim_mem+=$6/1000; next };  # there is a bug where bytes are given a unit of "m" but multiplied by 1000
    $2 in node && $6 ~ /[kK](i)?$/  { lim_mem+=$6*1024; next };
    $2 in node && $6 ~ /M(i)?$/     { lim_mem+=$6*1048576; next };
    $2 in node && $6 ~ /[gG](i)?$/  { lim_mem+=$6*1073741824; next };
    $2 in node && $6 ~ /[tT](i)?$/  { lim_mem+=$6*1099511627776; next };
    END {
        if ( output == "text" ) {
            printf("%-8s  %4s  %4s  %4s  %4s  %5s  %4s\n", "Resource", "Req", "%Req", "Lim", "%Lim", "Alloc", "Free");
            printf("%-8s  %4s  %3s%%  %4s  %3s%%  %5s  %4s\n", "CPU", cpu_pretty(req_cpu), calc_percentage(req_cpu, alloc_cpu), cpu_pretty(lim_cpu), calc_percentage(lim_cpu, alloc_cpu), cpu_pretty(alloc_cpu), cpu_pretty(calc_free(req_cpu, alloc_cpu)));
            printf("%-8s  %4s  %3s%%  %4s  %3s%%  %5s  %4s\n", "Memory", mem_pretty(req_mem), calc_percentage(req_mem, alloc_mem), mem_pretty(lim_mem), calc_percentage(lim_mem, alloc_mem), mem_pretty(alloc_mem), mem_pretty(calc_free(req_mem, alloc_mem)));
        }

        if ( output == "json" ) {
            printf("{");
            printf("\"CPU\": {");
            printf("\"requested\": %s,", req_cpu);
            printf("\"limits\": %s,", lim_cpu);
            printf("\"allocatable\": %s,", alloc_cpu);
            printf("\"utilization\": %d", req_cpu * 100 / alloc_cpu);
            printf("},");

            printf("\"Memory\": {");
            printf("\"requested\": %s,", req_mem);
            printf("\"limits\": %s,", lim_mem);
            printf("\"allocatable\": %s,", alloc_mem);
            printf("\"utilization\": %d", req_mem * 100 / alloc_mem);
            printf("}");
            printf("}");
        }
    }
    '
    awk -v output="${VIEW_UTILIZATION_OUTPUT}" "${VIEW_UTILIZATION_AWK_FN}${awkcmd}" <(get_node_data) <(get_pod_data)
}

namespace_utilization() {

    # shellcheck disable=SC2016
    awkcmd='BEGIN {FS="\t"};
    namespaces[$1];

    # CPU requests
    $3 ~ /[0-9]$/ { req_cpu[$1]+=$3*1000; };
    $3 ~ /m?$/    { req_cpu[$1]+=$3; };

    # memory requests
    $4 ~ /m$/         { req_mem[$1]+=$4/1000; };   # there is a bug where bytes are given a unit of "m" but multiplied by 1000
    $4 ~ /[kK](i)?$/  { req_mem[$1]+=$4*1024; };
    $4 ~ /M(i)?$/     { req_mem[$1]+=$4*1048576; };
    $4 ~ /[gG](i)?$/  { req_mem[$1]+=$4*1073741824; };
    $4 ~ /[tT](i)?$/  { req_mem[$1]+=$4*1099511627776; };

    # CPU limits
    $5 ~ /[0-9]$/ { lim_cpu[$1]+=$5*1000; };
    $5 ~ /m?$/    { lim_cpu[$1]+=$5; };

    # memory limits
    $6 ~ /m$/         { lim_mem[$1]+=$6/1000; next };  # there is a bug where bytes are given a unit of "m" but multiplied by 1000
    $6 ~ /[kK](i)?$/  { lim_mem[$1]+=$6*1024; next };
    $6 ~ /M(i)?$/     { lim_mem[$1]+=$6*1048576; next };
    $6 ~ /[gG](i)?$/  { lim_mem[$1]+=$6*1073741824; next };
    $6 ~ /[tT](i)?$/  { lim_mem[$1]+=$6*1099511627776; next };

    END {

        total_records=0;
        for (namespace in namespaces) {
            total_records++;
            nsindex[total_records]=namespace;
            if (longest_namespace_len < length(namespace)) longest_namespace_len = length(namespace)
        }
        if (longest_namespace_len < 9 ) longest_namespace_len = 9

        # sort namespaces alphabetically
        a_sort(nsindex)

        if ( output == "text" ) {

            printf("%-" longest_namespace_len "s%17s%15s%20s%18s\n", "NAMESPACE", "CPU Requests", "CPU Limits", "Memory Requests", "Memory Limits")
            for (z = 1; z in nsindex; z++) {
                printf("%-" longest_namespace_len "s%17s%15s%20s%18s\n", nsindex[z], cpu_pretty(req_cpu[nsindex[z]]), cpu_pretty(lim_cpu[nsindex[z]]), mem_pretty(req_mem[nsindex[z]]), mem_pretty(lim_mem[nsindex[z]]))
            }
        }

        if ( output == "json" ) {
            printf("{");

            for (z = 1; z in nsindex; z++) {
                printf("\"%s\": {", nsindex[z]);
                printf("\"CPU\": {");
                printf("\"requested\": %s,", (req_cpu[nsindex[z]]=="" ? "0" : req_cpu[nsindex[z]]));
                printf("\"limits\": %s", (lim_cpu[nsindex[z]]=="" ? "0" : lim_cpu[nsindex[z]]));
                printf("},");
                printf("\"Memory\": {");
                printf("\"requested\": %s,", (req_mem[nsindex[z]]=="" ? "0" : req_mem[nsindex[z]]));
                printf("\"limits\": %s", (lim_mem[nsindex[z]]=="" ? "0" : lim_mem[nsindex[z]]));
                printf("}");
                separator = (z < total_records ? "," : "");
                printf("}%s",separator);
            }
            printf("}");
        }
    }
    '
    awk -v output="${VIEW_UTILIZATION_OUTPUT}" "${VIEW_UTILIZATION_AWK_FN}${awkcmd}" <(get_pod_data)
}

VIEW_UTILIZATION_AWK_FN='
function a_sort(ary,   q, x, z){
   for (q in ary)
   {
      x = ary[q]
      for (z = q - 1; z && ary[z] > x; z--)
      {
         ary[z + 1] = ary[z]
      }
      ary[z + 1] = x
   }
   return a_join(ary, ORS)
}

function a_join(ary, sep,   q, x, z){
   # argument order is copacetic with Ruby
   for (q = 1; q in ary; q++)
   {
      if (x)
      {
         z = z sep ary[q]
      }
      else
      {
         z = ary[q]
         x = 1
      }
   }
   return z
}

function calc_free(requests, total) {
    if ( total >= requests ) {
        return (total - requests)
    } else {
        return "0"
    }
}

function calc_percentage(a,b){
    if ( a > 0 && b > 0 ) {
        return sprintf("%d", a * 100 / b);
    } else if ( b > 0 ) {
        return "0";
    } else {
        return "Err";
    }
}

function cpu_pretty(sum){
    if (sum < 10000) {
        ret = sprintf("%.2g",sum/1000)
    } else {
        ret = sprintf("%d",sum/1000)
    }
    return ret
}

function mem_pretty(sum){
    if (sum > 0) {
        hum[1024^4]="T";
        hum[1024^3]="G";
        hum[1024^2]="M";
        hum[1024^1]="K";
        hum[1]="";
        for (x=1024^4; x>=0; x/=1024){
            if (sum>=x) {
                if (sum/x <= 10){
                    ret = sprintf("%.2g%s",sum/x,hum[x]);break;
                } else {
                    ret = sprintf("%.f%s",sum/x,hum[x]);break;
                }
            }
        }
    } else {
        return "0"
    }
    return ret
}
'



if [ "${1}" == "namespaces" ]; then
    VIEW_UTILIZATION_SUBCOMMAND="namespaces"
    shift;
fi

optspec=":nlohv-:"
while getopts "$optspec" optchar; do
    case "${optchar}" in
        -)
            case "${OPTARG}" in
                namespace)
                    val="${!OPTIND}"; OPTIND=$(( OPTIND + 1 ))
                    if [[ "${val}" != "" ]]; then
                        VIEW_UTILIZATION_NAMESPACE="${val}"
                    else 
                        echo "no namespace specified"
                        exit 1
                    fi
                    ;;
                namespace=*)
                    val=${OPTARG#*=}
                    if [[ "${val}" != "" ]]; then
                        VIEW_UTILIZATION_NAMESPACE="${val}"
                    else 
                        echo "no namespace specified"
                        exit 1
                    fi
                    ;;
                selector)
                    val="${!OPTIND}"; OPTIND=$(( OPTIND + 1 ))
                    VIEW_UTILIZATION_NODE_LABEL="${val}"
                    ;;
                selector=*)
                    val=${OPTARG#*=}
                    VIEW_UTILIZATION_NODE_LABEL="${val}"
                    ;;
                output)
                    val="${!OPTIND}"; OPTIND=$(( OPTIND + 1 ))
                    if [[ "${val}" == "text" ]] || [[ "${val}" == "json" ]]; then
                        VIEW_UTILIZATION_OUTPUT=$val
                    else
                        echo "valid values are text, json"
                        exit 1
                    fi
                    ;;
                output=*)
                    val=${OPTARG#*=}
                    if [[ "${val}" == "text" ]] || [[ "${val}" == "json" ]]; then
                        VIEW_UTILIZATION_OUTPUT=$val
                    else
                        echo "valid values are text, json"
                        exit 1
                    fi
                    ;;
                *)
                    echo "Unknown option --${OPTARG}" >&2
                    exit 1
                    ;;
            esac;;
        n)
            shift
            if test $# -gt 0; then
                VIEW_UTILIZATION_NAMESPACE=$1
            else
                echo "no namespace specified"
                exit 1
            fi
            shift
            ;;
        l)
            shift
            if test $# -gt 0; then
                VIEW_UTILIZATION_NODE_LABEL=$1
            else
                echo "no label specified"
                exit 1
            fi
            shift
            ;;
        o)
            shift
            if test $# -gt 0; then
                if [[ "${1}" == "text" ]] || [[ "${1}" == "json" ]]; then
                    VIEW_UTILIZATION_OUTPUT=$1
                else
                    echo "valid values are text, json"
                    exit 1
                fi
            else
                echo "no output specified"
                exit 1
            fi
            shift
            ;;

        h)
            echo "usage: $0 [-v] [--namespace[=]<value>]" >&2
            echo "" >&2
            echo "-n[--namespace]     filter by namespace" >&2
            echo "-l[--selector]      filter by node label" >&2
            echo "-o[--output]        output [text/json] default text" >&2
            echo "-h                  prints help" >&2
            echo "-v                  prints version" >&2
            echo "subcommands:" >&2
            echo "    namespaces      shows namespace utilization" >&2
            exit
            ;;
        v)
            print_plugin_version
            ;;
        *)
            if [ "$OPTERR" != 1 ] || [ "${optspec:0:1}" = ":" ]; then
                echo "Non-option argument: '-${OPTARG}'" >&2
            fi
            ;;
    esac
done

if [ "${VIEW_UTILIZATION_SUBCOMMAND}" == "namespaces" ]; then
    namespace_utilization
else
    cluster_utilization
fi
